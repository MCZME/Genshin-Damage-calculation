# Core - 事件驱动系统 (Event System)

本项目采用解耦的、基于实例的事件驱动架构，用于处理各子系统间的通讯。

## 1. 结构化事件 (Dataclass Events)
所有事件均继承自 `GameEvent` 并定义在 `core/event.py` 中。使用 `dataclass` 提供了严格的类型提示。

### 1.1 核心事件类
- **`DamageEvent`**: 携带 `damage` 对象、来源与目标。
- **`HealEvent`**: 携带治疗数值与对象。
- **`ElementalReactionEvent`**: 携带反应类型与参与实体。
- **`CharacterSwitchEvent`**: 角色切换通知。

## 2. 层级机制与冒泡
事件不再是全局广播，而是遵循 **实体 -> 场景 -> 全局** 的传播链条。

1. **发布 (`publish`)**: 实体产生的动作首先发布到自身的局部 `EventEngine`。
2. **冒泡 (Bubbling)**: 若局部未停止传播，事件会自动通过 `parent` 引用上传至全局 `SimulationContext`。
3. **拦截与取消**:
    - **`event.cancel()`**: 逻辑意义上的取消（如伤害被无敌拦截），后续 System 仍能看到但通常不执行逻辑。
    - **`event.stop_propagation()`**: 物理意义上的拦截，防止事件冒泡。

## 3. 事件监听 (`EventHandler`)
任何需要响应事件的类（如 `GameSystem` 或 `Effect`）必须实现 `handle_event` 接口：

```python
class MySystem(GameSystem):
    def register_events(self, engine: EventEngine):
        # 向当前环境的引擎订阅
        engine.subscribe(EventType.BEFORE_DAMAGE, self)

    def handle_event(self, event: GameEvent):
        if event.event_type == EventType.BEFORE_DAMAGE:
            # 执行逻辑
            pass
```

## 4. [Important] 弃用说明
原有的全局 `EventBus` 现已标记为 **Deprecated**。新代码应始终通过 `get_context().event_engine` 或 `entity.event_engine` 进行订阅与发布，以维持 Context 隔离。

---
*版本: V2.5*
*更新日期: 2026-02-07*
