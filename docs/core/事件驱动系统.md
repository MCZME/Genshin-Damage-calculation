# Core - 事件驱动系统 (Event System)

本项目采用解耦的、基于实例的事件驱动架构，用于处理各仿真子系统间的通讯与逻辑触发。

## 1. 结构化事件 (Dataclass Events)
所有事件均继承自 `GameEvent` 并定义在 `core/event.py` 中。使用 `dataclass` 提供了严格的类型提示与字段校验。

### 1.1 核心事件类
- **`DamageEvent`**: 核心伤害事件，携带 `damage` 对象、来源（source）与目标（target）。
- **`HealEvent`**: 携带治疗数值与对象信息。
- **`ElementalReactionEvent`**: 携带反应类型与参与实体。
- **`CharacterSwitchEvent`**: 角色切换通知，常用于重置快照或触发换人 Buff。
- **`ActionEvent`**: 通用动作事件（如 `BEFORE_SKILL`, `AFTER_BURST`），用于驱动状态机与视觉同步。

## 2. 上下文隔离机制
在 V2.3 架构中，事件引擎不再是全局单例，而是**与 `SimulationContext` 绑定**。

1. **局部性**: 所有的订阅与发布必须通过 `get_context().event_engine` 进行。这确保了在多线程或并发仿真环境下，事件不会跨上下文交叉。
2. **发布流程**:
    - 实体通过 `self.event_engine.publish(event)` 发布事件。
    - 引擎遍历该类型的订阅者列表（Snapshot 迭代，防止在处理过程中修改列表导致崩溃）。
    - 检查 `event.cancelled` 状态：若被前面的处理器取消，后续处理器将跳过逻辑。

## 3. 事件监听接口 (`EventHandler`)
任何需要响应事件的类（如 `GameSystem` 或 `Effect`）必须实现 `handle_event` 抽象方法：

```python
class MyEffect(Effect, EventHandler):
    def apply(self, target):
        # 订阅事件
        get_context().event_engine.subscribe(EventType.BEFORE_DAMAGE, self)

    def handle_event(self, event: GameEvent):
        if event.event_type == EventType.BEFORE_DAMAGE:
            # 修改计算状态
            event.data["damage_context"].stats["伤害加成"] += 20
```

## 4. [Critical] 移除声明
**全局 `EventBus` 类已被彻底从代码库中移除。** 

**迁移指南：**
- `EventBus.publish(...)` -> `get_context().event_engine.publish(...)`
- `EventBus.subscribe(...)` -> `get_context().event_engine.subscribe(...)`
- 移除所有 `from core.event import EventBus` 的引用。

---
*版本: V2.3.1 (Context-Bound)*
*更新日期: 2026-02-12*
