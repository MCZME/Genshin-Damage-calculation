# Core - 事件驱动系统 (Event System)

本项目采用解耦的、基于实例的事件驱动架构。在 V2.4 版本中，事件流被严格划分为三个层级，以确保仿真逻辑的严密性并防止递归死循环。

---

## 1. 三段式事件流规范 (V2.4)

### 1.1 意图层 (Intent Phase)
*   **代表事件**：`BEFORE_SKILL`, `BEFORE_DASH`, `BEFORE_SWITCH`
*   **发布者**：`Character` 或 `Skill` 实例
*   **职责**：宣告一个逻辑动作的开始。
*   **用途**：
    *   执行“快照 (Snapshot)”锁定属性。
    *   扣除能量、体力或触发 CD。
    *   *规范*：允许在此阶段取消（Cancel）后续所有流程。

### 1.2 系统核心/修正层 (Pipeline Phase)
*   **代表事件**：`BEFORE_CALCULATE` (伤害合算前), `BEFORE_HEAL` (治疗应用前)
*   **发布者**：`DamageSystem`, `HealthSystem` 等原子系统。
*   **职责**：在最终数值生效前，允许 Buff/Effect 对计算上下文进行最后修正。
*   **用途**：
    *   **动态注入**：例如芙宁娜根据气氛值注入“伤害加成”或“受治疗加成”。
    *   **拦截**：例如无敌帧检测。
    *   **[Critical] 防死循环**：严禁在此阶段的监听器中再次发布会导致系统重入的伤害/治疗请求。

### 1.3 结果/反馈层 (Result Phase)
*   **代表事件**：`AFTER_DAMAGE`, `AFTER_HURT`, `AFTER_HEAL`, `AFTER_REACTION`
*   **发布者**：系统核心（在逻辑执行完毕且数值写入实体后）。
*   **职责**：宣告一个事实已经发生。
*   **用途**：
    *   **机制触发**：例如芙宁娜监听到 `AFTER_HURT` 后累加气氛值。
    *   **计数器推进**：ICD 计数、命中次数统计。
    *   *规范*：此阶段事件应视为“只读”，不建议修改已结算的数值。

---

## 2. 结构化事件 (Dataclass Events)
所有事件均继承自 `GameEvent` 并在 `core/event.py` 中定义。

### 2.1 核心事件类
- **`DamageEvent`**: 携带 `damage` 对象。
- **`HealEvent`**: 携带治疗对象。
- **`CharacterSwitchEvent`**: 逻辑队伍中的活跃索引变更。
- **`ActionEvent`**: 时序相关事件（如帧命中、动作取消）。

---

## 3. 上下文隔离与生命周期
事件引擎与 `SimulationContext` 严格绑定。

1.  **局部性**: 严禁跨上下文订阅。
2.  **订阅管理**: `Effect` 必须在 `on_apply` 时订阅，在 `on_remove` 时**必须取消订阅**，否则会导致内存泄漏与逻辑漂移。
3.  **传播控制**: 
    - `event.cancelled = True`: 立即终止该事件后续所有监听器的执行。
    - `event.propagation_stopped = True`: 阻止该事件冒泡至父级引擎。

---

## 4. 最佳实践
*   **只监听必要的层级**：如果只需要知道伤害结果，请监听 `AFTER_DAMAGE` 而不是 `BEFORE_DAMAGE`。
*   **避免链式触发**：Effect A 产生伤害 -> AFTER_DAMAGE -> Effect B 产生治疗 -> AFTER_HEAL -> Effect A... 必须通过逻辑计数器或帧限制强行断开。
*   **数据隔离**：尽量通过 `event.data` 传递上下文对象（如 `DamageContext`），避免直接修改全局单例。

---
*版本: V2.4 (Structured Flow)*
*更新日期: 2026-02-12*
