# 架构设计：角色子类适配指南 (V2.4 - 精准物理版)

## 1. 概述
本指南确立了角色子类在 V2.4 战斗仿真引擎下的重构规范。核心演进在于 **“逻辑与物理的深度解耦”**、**“精细化动作中断控制”** 以及 **“空间感知伤害判定”**。

---

## 2. 目录结构与数据解耦 (Modular Structure)
必须采用以下文件布局以实现逻辑解耦与 Registry 自动扫描：

```text
character/REGION/char_name_en/
├── __init__.py        # 注册与导出
├── char.py            # 核心编排类
├── data.py            # [自动+交互] 数据层：存放倍率、物理、机制常量
├── skills.py          # 意图 -> 动作转换逻辑
├── talents.py         # 固有天赋定义
├── constellations.py  # 命座定义
├── entities.py        # [可选] 召唤物/部署物实体
└── effects.py         # [可选] 特有状态逻辑
```

### 2.1 物理与逻辑解耦 (Decoupling)
**准则**：角色不再单独注册到物理空间，而是通过 `Team` 进行管理。
- **级联驱动**：全队角色的逻辑（ASM、技能 CD、充能等）统一由 `Team.on_frame_update()` 驱动。
- **物理感知**：`CombatSpace` 现在包含了 `Team`。在执行空间检索（如 AOE）时，空间会自动合并当前活跃角色的物理信息。坐标继承与物理点切换由 `Team` 自动处理。

### 2.2 局部配置中心 (`data.py`)
严禁在逻辑代码中硬编码数值。`data.py` 必须分为以下独立字典：
- **`BASE_STATS`**: 自动化获取的 1-100 级属性。
- **`SKILL_MULTIPLIERS`**: 高精度倍率序列。
- **`ACTION_FRAME_DATA`**: 实测时序（含 `hit_frames`, `total_frames`, `interrupt_frames`）。
- **`ATTACK_DATA`**: 攻击契约（含 Hitbox、ICD 共享组 `icd_group`、打击类型）。
- **`MECHANISM_CONFIG`**: 逻辑驱动常量（如形态切换帧、治疗频率）。

---

## 3. 标准开发流 (SOP v2.4)

### 第一阶段：自动化获取与基础验证 (Base)
1.  运行 `fetch_content.py` 自动生成属性与倍率。
2.  **[人工确认]** 核对 `data.py` 中的数值准确性。

### 第二阶段：物理数据交互录入 (Physics)
1.  将实测 CSV 中的帧数、中断窗口及碰撞范围录入 `data.py` 的对应字典。
2.  **[人工确认]** 确认物理转译（形状尺寸、偏移、ICD 共享组）正确。

### 第三阶段：组件化迭代开发 (Implementation)
1.  **组件化实现**：按实体 -> 效果 -> 技能顺序分块实现。
2.  **伤害审计对接**：增益注入严禁修改 `stats` 字典，必须通过 `ctx.add_modifier(source, stat, value)`。
3.  **[人工确认]** 获得授权后方可进入下一块。

### 第四阶段：总装与质量验证 (Verification)
1.  在 `char.py` 中挂载组件，使用 `Simulator` 运行测试序列并审计 `EventFlow` 日志。

---

## 4. 核心重构契约 (Initialization Hooks)

### 4.1 构造函数规范 (Constructor Hygiene)
**强制禁令**：
1. **严禁使用 `**kwargs`**：所有参数（`id`, `level`, `skill_params`, `constellation`, `base_data`）必须显式声明并透传。
2. **严禁手动构造 `base_data`**：角色类仅负责逻辑编排，不负责准备初始数据。数据应由 `TeamFactory` 或测试环境传入。
3. **正确继承**：必须优先继承所属区域的基类（如 `Region/REGION/region.py`），以确保自动获得该地区的通用机制（如枫丹角色的“荒芒”属性 `self.arkhe`）。

### 4.2 `_setup_character_components()`
**职责**：实例化技能对象与能量系统。
**命名要求**：字典 Key 必须直接匹配后端 Action ID。
```python
def _setup_character_components(self):
    self.skills = {
        "normal_attack": FurinaNormalAttack(self.skill_params[0], self),
        "charged_attack": FurinaChargedAttack(self.skill_params[0], self),
        "plunging_attack": FurinaPlungingAttack(self.skill_params[0], self),
        "elemental_skill": FurinaElementalSkill(self.skill_params[1], self),
        "elemental_burst": FurinaElementalBurst(self.skill_params[2], self),
        "dash": DashSkill(caster=self),
        "skip": SkipSkill(caster=self)
    }
```

### 4.3 `_perform_tick()`
**职责**：实现角色每帧的业务逻辑。
**规范**：严禁直接重写 `on_frame_update()`。必须将逻辑挂载至 `_perform_tick()` 钩子，以确保基类的生命周期维护逻辑（如帧数自增）不被破坏。

### 4.2 `_setup_effects()`
**职责**：填充天赋与命座列表。
```python
def _setup_effects(self):
    self.talents = [Passive1(), Passive2()]
    self.constellations = [C1(), C2(), None, C4(), None, C6()] # 支持占位
```

---

## 5. 意图驱动与动作生成 (Intent-Driven)

### 5.1 精准动作工厂化 (`skills.py`)
技能类必须实现 `to_action_data(intent)` 接口，执行物理与时序的“手工装配”。

**核心规范**：
1.  **原生索引**：`ACTION_FRAME_DATA` 必须使用中文键名（如 `元素战技-荒`）。
2.  **标签映射**：技能应在 `__init__` 中管理 `self.label_map`（物理动作名 -> 伤害倍率标签）。

```python
class ElementalSkill(SkillBase):
    def to_action_data(self, intent: dict = None) -> ActionFrameData:
        # 1. 提取实测数据 (使用统一的中文 Key)
        frames = ACTION_FRAME_DATA["元素战技-荒"]
        physics = ATTACK_DATA["元素战技"] 
        
        return ActionFrameData(
            name="元素战技",
            action_type="elemental_skill",
            total_frames=frames["total_frames"],
            hit_frames=frames["hit_frames"],
            interrupt_frames=frames["interrupt_frames"],
            attack_config=AttackConfig(
                attack_tag=physics["attack_tag"],
                hitbox=HitboxConfig(shape=AOEShape.SPHERE, radius=physics["radius"])
            ),
            origin_skill=self
        )
```

---

## 6. 动作元数据规范 (Action Metadata Discovery)
UI 直接传输标准后端 Key，不再进行 ID 映射。角色类通过 `get_action_metadata()` 类方法声明其可接受的参数。

### 6.1 统一 Action Key
标准 Key 包含：`normal_attack`, `elemental_skill`, `elemental_burst`, `charged_attack`, `plunging_attack`, `dash`, `skip`。

### 6.2 普通攻击 `count` 逻辑
UI 参数名必须为 **`count`** (类型: int)，代表“执行连招次数”。模拟器层的 `ActionParser` 会自动将其展开为多条连续指令。

### 6.3 参数定义字段 (Parameter Schema)
`params` 列表中的每个参数项需包含：
- **`key`**: (str) 传递给 `to_action_data` 的字典键。
- **`label`**: (str) UI 显示的文本。
- **`type`**: (str) 支持 `int`, `float`, `select`, `bool`。
- **`default`**: 默认值。
- **`min` / `max`**: (Optional) 数值范围。
    - **Slider 触发**: 当 `type="int"` 且 `max - min <= 10` 时，UI 自动呈现为滑动条。

### 6.4 实现示例
```python
@classmethod
def get_action_metadata(cls) -> Dict[str, Any]:
    return {
        "normal_attack": {
            "label": "普通攻击",
            "params": [
                {"key": "count", "label": "连招次数", "type": "int", "min": 1, "max": 5, "default": 1}
            ]
        },
        "skip": {
            "label": "等待",
            "params": [
                {"key": "frames", "label": "帧数", "type": "int", "min": 1, "max": 3600, "default": 60}
            ]
        }
    }
```

---

## 7. 关键原则总结
1.  **空间广播**：禁止在技能中寻找 `target`，应通过 `ctx.space.broadcast_damage` 执行范围判定。
2.  **去物理化**：UI 仅传输逻辑意图（Intent），物理表现由 `data.py` 与 `ASM` 共同决定。
3.  **驱动唯一性**：逻辑驱动权完全收拢于 `Team` 与 `_perform_tick`，严禁多重驱动角色。
4.  **物理高度感知**：下落攻击必须在 `on_frame_update` 中进行 Y 轴监测，状态快照由启动瞬间决定。
5.  **标准化辅助动作**：所有角色应挂载 `SkipSkill`（Key 为 `skip`），用于在序列中插入空闲等待。

---
*版本: V2.4.2 (Scene-Centric & Cascade Driving)*
*更新日期: 2026-02-14*
