# 架构设计：角色子类适配指南 (V2.3 - 意图驱动版)

## 1. 概述
本指南确立了角色子类在 V2.3 场景仿真引擎下的模块化重构规范。核心演进在于从“过程式调用”转向“意图驱动 (Intent-Driven)”，并引入“元数据发现”机制以支持 UI 动态生成。

---

## 2. 目录结构规范 (Modular Structure)
必须采用以下文件布局以实现逻辑解耦与 Registry 自动扫描。推荐将天赋与命座逻辑拆分以提高可维护性：

```text
character/REGION/char_name/
├── __init__.py        # 导出核心角色类，处理注册
├── char.py            # 核心组装类 (继承 Character)，负责组件编排
├── skills.py          # 技能逻辑实现 (Normal, Skill, Burst)
├── talents.py         # 固有天赋定义 (TalentEffect)
├── constellations.py  # 命座定义 (ConstellationEffect)
├── entities.py        # [可选] 战场物理实体 (召唤物、部署物)
└── effects.py         # [可选] 角色特有状态逻辑 (Buff、印记)
```

---

## 3. 开发工作流 (Development SOP)

### 第一阶段：规格定义 (Specification)
1.  **意图建模**：识别角色动作的分支（如点按/长按、蓄力段数）。
2.  **Schema 设计**：设计 `get_action_metadata()` 返回的字典结构，确保 UI 能够感知所有逻辑参数。
3.  **数据采集**：准备各等级倍率、产球概率及精准的帧数数据（总帧、命中帧、取消帧）。

### 第二阶段：逻辑实现 (Implementation)
1.  **技能解耦**：在 `skills.py` 中实现 `to_action_data(intent)`。根据 UI 传来的意图字典，动态生成 `ActionFrameData`。
2.  **动态效果**：在 `talents.py` 中实现天赋逻辑。使用 `on_frame_update` 处理持续效果，使用事件监听处理触发类效果。
3.  **组件编排**：在 `char.py` 的钩子函数中完成实例化。

### 第三阶段：质量验证 (Verification)
1.  **静态验证**：检查基础面板与突破属性在不同等级下的正确性。
2.  **动态验证**：使用 `Simulator` 运行特定序列，验证伤害触发帧（Hit Frames）与倍率应用是否符合预期。
3.  **UI 预览**：在 Workbench 中确认参数调节器（Inspector）能根据 Metadata 正确生成。

---

## 4. 核心重构契约 (Initialization Hooks)

### 4.1 `_setup_character_components()`
**职责**：实例化技能对象与能量系统。
```python
def _setup_character_components(self):
    self.elemental_energy = ElementalEnergy(self, ('冰', 80))
    self.skills = {
        "normal": NormalAttack(self.skill_params[0]),
        "skill": ElementalSkill(self.skill_params[1]),
        "burst": ElementalBurst(self.skill_params[2])
    }
```

### 4.2 `_setup_effects()`
**职责**：填充天赋与命座列表。
```python
def _setup_effects(self):
    self.talents = [Passive1(), Passive2()]
    self.constellations = [C1(), C2(), None, C4(), None, C6()] # 支持占位
```

---

## 5. 意图驱动与动作生成 (Intent-Driven)

### 5.1 技能工厂化 (`skills.py`)
技能类必须实现 `to_action_data(intent)` 接口。物理参数（位移、帧数）在此时固化，UI 不参与计算。

```python
class ElementalSkill(SkillBase):
    def to_action_data(self, intent: dict = None) -> ActionFrameData:
        intent = intent or {}
        # 解析逻辑意图
        mode = intent.get("mode", "Press")
        
        if mode == "Hold":
            return ActionFrameData(name="E_HOLD", total_frames=120, hit_frames=[60, 80])
        return ActionFrameData(name="E_PRESS", total_frames=40, hit_frames=[15])
```

---

## 6. 元数据发现机制 (Metadata Discovery)

UI 通过类方法感知参数 Schema，实现无码化渲染。

```python
@classmethod
def get_action_metadata(cls) -> Dict[str, Any]:
    return {
        "elemental_skill": {
            "label": "元素战技",
            "params": [
                {
                    "key": "mode", 
                    "label": "施放模式", 
                    "type": "select", 
                    "options": {"Press": "点按", "Hold": "长按"}, 
                    "default": "Press"
                }
            ]
        }
    }
```

---

## 7. 关键原则总结
1.  **去物理化**：UI 仅传输逻辑意图（Intent），不传输坐标、位移或帧数。
2.  **注册规范**：统一使用 **角色名称字符串** 进行注册（`@register_character("玛薇卡")`）。
3.  **独立性**：技能对象应作为“动作生产者”，尽量减少对外部全局状态的直接修改。

---
*版本: V2.3.1 (SOP & Modular)*
*更新日期: 2026-02-12*
