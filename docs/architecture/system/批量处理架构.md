# 架构设计：批量处理系统 (V3.3 - Rules-Driven Architecture)

## 1. 设计愿景
批量处理（Batch Processing）在 V3.3 中实现了 **“零状态存储”** 架构。节点不再存储庞大的配置快照，而是仅记录变异规则，通过路径派生算法实时生成仿真任务，极大地降低了超大规模变异树的内存开销。

---

## 2. 核心架构：规则派生模型

### 2.1 零快照机制
*   **内存优化**: `SimulationNode` 仅保存 `ModifierRule`。
*   **根配置 (Root Config)**: 仅根节点感知当前的“工作台环境”。
*   **实时派生**: 使用 `ConfigGenerator.resolve_node_config` 递归应用路径上的所有规则，按需生成最终的仿真 JSON。

### 2.2 节点类型
1.  **普通节点**: 用户手动创建，可定义单一变异规则。
2.  **区间锚点 (Range Anchor)**: 由区间扫描模式生成的容器节点，本身不带规则，仅作为组织者。
3.  **受控节点 (Managed Node)**: 由区间扫描器批量生成的具体数值节点。它们受父级锚点生命周期管理，不可单独删除。

---

## 3. 变异逻辑：区间扫描 (Range Scanning)

### 3.1 自动展开逻辑
*   用户定义 `[Start, End, Step]`。
*   系统自动在当前节点下创建 N 个受控子节点。
*   每个受控子节点继承父级的路径，并携带固定的 `REPLACE` 值。

### 3.2 级联性
*   父节点（锚点）的删除会触发整棵子树的销毁。
*   受控节点允许继续繁衍手动分支，实现如 `[等级区间] -> [武器对比]` 的多维交叉测试。

---

## 4. 数据持久化 (Persistence)

*   **结构化保存**: 仅序列化树形结构与规则。
*   **环境解耦**: 不保存 `root_config`。这允许用户将一套复杂的“批处理方案”直接加载到不同的角色或队伍配置中，实现逻辑复用。

---
*版本: V3.3 (Zero-Snapshot & Range Support)*
*日期: 2026-02-11*
